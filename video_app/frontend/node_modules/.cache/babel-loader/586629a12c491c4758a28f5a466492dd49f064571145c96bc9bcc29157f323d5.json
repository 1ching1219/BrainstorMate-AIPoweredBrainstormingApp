{"ast":null,"code":"// import React, { useState, useEffect, useRef } from 'react';\n// import { useParams, useLocation, useNavigate } from 'react-router-dom';\n// import styled from 'styled-components';\n// import Peer from 'simple-peer';\n// import axios from 'axios';\n// import Chat from './Chat';\n// import { useSearchParams } from 'react-router-dom';\n\n// const VideoRoomContainer = styled.div`\n//   display: flex;\n//   flex-direction: column;\n//   height: 100vh;\n//   width: 100%;\n//   position: relative;\n// `;\n\n// const Header = styled.div`\n//   display: flex;\n//   justify-content: center; // Center the room title\n//   align-items: center;\n//   padding: 12px 16px;\n//   border-bottom: 1px solid #e0e0e0;\n// `;\n\n// const RoomTitle = styled.h2`\n//   margin: 0;\n//   font-size: 16px;\n//   font-weight: 600;\n// `;\n\n// const FeedbackSection = styled.div`\n//   flex: 1;\n//   overflow-y: auto;\n//   padding: 16px;\n//   background-color: #fff;\n//   border-bottom: 1px solid #e0e0e0;\n// `;\n\n// const FeedbackItem = styled.div`\n//   display: flex;\n//   margin-bottom: 16px;\n// `;\n\n// const Avatar = styled.div`\n//   width: 40px;\n//   height: 40px;\n//   border-radius: 20px;\n//   background-color: #e0e0e0;\n//   margin-right: 12px;\n//   overflow: hidden;\n//   display: flex;\n//   justify-content: center;\n//   align-items: center;\n// `;\n\n// const AvatarImage = styled.img`\n//   width: 100%;\n//   height: 100%;\n//   object-fit: cover;\n// `;\n\n// const FeedbackContent = styled.div`\n//   flex: 1;\n// `;\n\n// const AgentName = styled.div`\n//   font-weight: 600;\n//   font-size: 14px;\n//   margin-bottom: 4px;\n// `;\n\n// const FeedbackText = styled.div`\n//   font-size: 14px;\n// `;\n\n// const VideoGrid = styled.div`\n//   display: grid;\n//   grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n//   gap: 16px;\n//   padding: 16px;\n//   background-color: #f5f5f5;\n//   flex: 1;\n//   position: relative;\n// `;\n\n// const VideoContainer = styled.div`\n//   position: relative;\n//   aspect-ratio: 4/3;\n//   background-color: #000;\n//   border-radius: 8px;\n//   overflow: hidden;\n// `;\n\n// const ParticipantVideo = styled.video`\n//   width: 100%;\n//   height: 100%;\n//   object-fit: cover;\n// `;\n\n// const ParticipantName = styled.div`\n//   position: absolute;\n//   bottom: 10px;\n//   left: 10px;\n//   background-color: rgba(0, 0, 0, 0.6);\n//   color: white;\n//   padding: 4px 8px;\n//   border-radius: 4px;\n//   font-size: 12px;\n// `;\n\n// // New styled component for self-video in bottom right\n// const SelfVideoContainer = styled.div`\n//   position: absolute;\n//   bottom: 10px; // Position above control bar\n//   right: 10px;\n//   width: 180px; // Smaller size\n//   border-radius: 8px;\n//   overflow: hidden;\n//   aspect-ratio: 4/3;\n//   background-color: #000;\n//   z-index: 10;\n//   box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n//   display: ${props => props.visible ? 'block' : 'none'}; // Hide when video is off\n// `;\n\n// const ControlBar = styled.div`\n//   display: flex;\n//   justify-content: center;\n//   padding: 16px;\n//   background-color: #fff;\n//   border-top: 1px solid #e0e0e0;\n// `;\n\n// const ControlButton = styled.button`\n//   width: 40px;\n//   height: 40px;\n//   border-radius: 20px;\n//   margin: 0 8px;\n//   background-color: ${props => props.danger ? '#ff4d4f' : '#f0f0f0'};\n//   color: ${props => props.danger ? 'white' : 'black'};\n//   border: none;\n//   cursor: pointer;\n//   display: flex;\n//   align-items: center;\n//   justify-content: center;\n\n//   &:hover {\n//     background-color: ${props => props.danger ? '#ff7875' : '#d9d9d9'};\n//   }\n// `;\n\n// const ChatButton = styled.button`\n//   display: flex;\n//   align-items: center;\n//   justify-content: center;\n//   width: 40px;\n//   height: 40px;\n//   border-radius: 20px;\n//   background-color: #f0f0f0;\n//   border: none;\n//   cursor: pointer;\n//   margin-right: 16px;\n\n//   &:hover {\n//     background-color: #d9d9d9;\n//   }\n// `;\n\n// const VideoRoom = () => {\n//   const { roomId } = useParams();\n//   const location = useLocation();\n//   const navigate = useNavigate();\n//   const [aiPartners, setAiPartners] = useState(location.state?.aiPartners || []);\n//   const [userName, setUserName] = useState(localStorage.getItem('userName') || 'You');\n//   const [peers, setPeers] = useState([]);\n//   const [participants, setParticipants] = useState([]);\n//   const [messages, setMessages] = useState([]);\n//   const [aiFeedback, setAiFeedback] = useState([]);\n//   const [showChat, setShowChat] = useState(false);\n//   const [videoEnabled, setVideoEnabled] = useState(true);\n//   const [audioEnabled, setAudioEnabled] = useState(true);\n\n//   const userVideo = useRef();\n//   const peersRef = useRef([]);\n//   const socketRef = useRef();\n//   const streamRef = useRef();\n\n//   useEffect(() => {\n//     // Connect to the WebSocket\n\n//     socketRef.current = new WebSocket(`ws://localhost:8002/ws/chat/${roomId}/`);\n\n//     // Get user media and set up connections\n//     navigator.mediaDevices.getUserMedia({ video: true, audio: true })\n//       .then(stream => {\n//         streamRef.current = stream;\n//         if (userVideo.current) {\n//           userVideo.current.srcObject = stream;\n//         }\n\n//         // Join room\n//         joinRoom();\n\n//         // Set up WebSocket handlers\n//         setupWebSocket();\n\n//         // Get participants and messages\n//         fetchParticipants();\n//         fetchMessages();\n\n//         // Generate AI feedback\n//         if (aiPartners.length > 0) {\n//           generateAIFeedback();\n//         }\n//       })\n//       .catch(error => {\n//         console.error(\"Error accessing media devices:\", error);\n//         alert(\"Could not access camera or microphone. Please check permissions.\");\n//       });\n\n//     return () => {\n//       // Clean up\n//       if (streamRef.current) {\n//         streamRef.current.getTracks().forEach(track => track.stop());\n//       }\n//       if (socketRef.current) {\n//         socketRef.current.close();\n//       }\n//       peersRef.current.forEach(peer => {\n//         if (peer.peer) {\n//           peer.peer.destroy();\n//         }\n//       });\n//     };\n//   }, [roomId]);\n\n//   const joinRoom = async () => {\n//     try {\n//       // Register participant in the room\n//       await axios.post(`/api/rooms/${roomId}/join/`, {\n//         name: userName,\n\n//         is_ai: false\n//       });\n\n//       // Register AI partners in the room\n//       for (const agent of aiPartners) {\n//         await axios.post(`/api/rooms/${roomId}/join/`, {\n//           name: agent.name,\n//           is_ai: true,\n//           ai_agent: agent.id\n//         });\n//       }\n//     } catch (error) {\n//       console.error(\"Error joining room:\", error);\n//     }\n//   };\n\n//   const setupWebSocket = () => {\n//     socketRef.current.onopen = () => {\n//       console.log(\"WebSocket connection established\");\n\n//       // Signal to other participants that we've joined\n//       socketRef.current.send(JSON.stringify({\n//         type: 'signal',\n//         signal: { type: 'new-participant' },\n//         caller_id: userName\n//       }));\n//     };\n\n//     socketRef.current.onmessage = (event) => {\n//       const data = JSON.parse(event.data);\n\n//       if (data.type === 'message') {\n//         setMessages(prevMessages => [...prevMessages, {\n//           sender: data.sender,\n//           content: data.message,\n//           is_ai: data.is_ai\n//         }]);\n\n//         // If AI message contains feedback, add it to feedback section\n//         if (data.is_ai && data.message_type === 'feedback') {\n//           setAiFeedback(prev => [...prev, {\n//             agent: data.sender,\n//             content: data.message\n//           }]);\n//         }\n//       } else if (data.type === 'signal') {\n//         handleSignal(data);\n//       }\n//     };\n\n//     socketRef.current.onerror = (error) => {\n//       console.error(\"WebSocket error:\", error);\n//     };\n\n//     socketRef.current.onclose = () => {\n//       console.log(\"WebSocket connection closed\");\n//     };\n//   };\n\n//   const handleSignal = (data) => {\n//     const { signal, caller_id, receiver_id } = data;\n\n//     // If signal is for a new participant\n//     if (signal.type === 'new-participant' && caller_id !== userName) {\n//       const peer = createPeer(caller_id);\n\n//       peersRef.current.push({\n//         peerId: caller_id,\n//         peer: peer\n//       });\n\n//       socketRef.current.send(JSON.stringify({\n//         type: 'signal',\n//         signal: { type: 'participant-ready' },\n//         caller_id: userName,\n//         receiver_id: caller_id\n//       }));\n//     }\n\n//     // If signal is from a participant who is ready to connect\n//     else if (signal.type === 'participant-ready' && receiver_id === userName) {\n//       const peer = addPeer(caller_id, signal);\n\n//       peersRef.current.push({\n//         peerId: caller_id,\n//         peer: peer\n//       });\n//     }\n\n//     // Handle WebRTC signaling\n//     else if (signal.sdp || signal.candidate) {\n//       const item = peersRef.current.find(p => p.peerId === caller_id);\n//       if (item) {\n//         item.peer.signal(signal);\n//       }\n//     }\n//   };\n\n//   const createPeer = (participantId) => {\n//     const peer = new Peer({\n//       initiator: true,\n//       trickle: false,\n//       stream: streamRef.current\n//     });\n\n//     peer.on('signal', signal => {\n//       socketRef.current.send(JSON.stringify({\n//         type: 'signal',\n//         signal: signal,\n//         caller_id: userName,\n//         receiver_id: participantId\n//       }));\n//     });\n\n//     peer.on('stream', stream => {\n//       setPeers(users => [...users, {\n//         id: participantId,\n//         stream: stream\n//       }]);\n//     });\n\n//     return peer;\n//   };\n\n//   const addPeer = (participantId, incomingSignal) => {\n//     const peer = new Peer({\n//       initiator: false,\n//       trickle: false,\n//       stream: streamRef.current\n//     });\n\n//     peer.on('signal', signal => {\n//       socketRef.current.send(JSON.stringify({\n//         type: 'signal',\n//         signal: signal,\n//         caller_id: userName,\n//         receiver_id: participantId\n//       }));\n//     });\n\n//     peer.on('stream', stream => {\n//       setPeers(users => [...users, {\n//         id: participantId,\n//         stream: stream\n//       }]);\n//     });\n\n//     peer.signal(incomingSignal);\n\n//     return peer;\n//   };\n\n//   const fetchParticipants = async () => {\n//     try {\n//       const response = await axios.get(`/api/rooms/${roomId}/participants/`);\n//       setParticipants(response.data);\n//     } catch (error) {\n//       console.error(\"Error fetching participants:\", error);\n//     }\n//   };\n\n//   const fetchMessages = async () => {\n//     try {\n//       const response = await axios.get(`/api/rooms/${roomId}/messages/`);\n//       setMessages(response.data);\n//     } catch (error) {\n//       console.error(\"Error fetching messages:\", error);\n//     }\n//   };\n\n//   const generateAIFeedback = () => {\n//     // Simulated AI feedback for demonstration\n//     // In a real application, this would come from an AI service\n//     const initialFeedback = aiPartners.map(agent => ({\n//       agent: agent.name,\n//       content: `Hello, I'm ${agent.name}, your ${agent.role} AI assistant. I'm here to help with the meeting.`\n//     }));\n\n//     setAiFeedback(initialFeedback);\n\n//     // Simulate AI sending periodic feedback\n//     const feedbackInterval = setInterval(() => {\n//       const randomAgent = aiPartners[Math.floor(Math.random() * aiPartners.length)];\n//       if (randomAgent) {\n//         const feedback = {\n//           agent: randomAgent.name,\n//           content: generateRandomFeedback(randomAgent.role)\n//         };\n\n//         setAiFeedback(prev => [...prev, feedback]);\n\n//         // Also send to chat\n//         if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {\n//           socketRef.current.send(JSON.stringify({\n//             type: 'message',\n//             message: feedback.content,\n//             sender: feedback.agent,\n//             is_ai: true,\n//             message_type: 'feedback'\n//           }));\n//         }\n//       }\n//     }, 15000); // Every 15 seconds\n\n//     return () => clearInterval(feedbackInterval);\n//   };\n\n//   const generateRandomFeedback = (role) => {\n//     const feedbackOptions = {\n//       'Designer': [\n//         \"I notice the UI elements could be more consistent. Consider a unified color scheme.\",\n//         \"The user flow seems to have some friction points. We should simplify the navigation.\",\n//         \"Visual hierarchy could be improved to guide users more effectively.\",\n//         \"Have you considered accessibility in this design? Some elements may need better contrast.\"\n//       ],\n//       'Engineer': [\n//         \"The current architecture might have scaling issues with high user loads.\",\n//         \"We should consider optimizing the database queries for better performance.\",\n//         \"This would be a good opportunity to implement caching to reduce server load.\",\n//         \"The current solution works, but we might want to refactor for better maintainability.\"\n//       ],\n//       'Finance': [\n//         \"Based on our projections, we should allocate more resources to marketing.\",\n//         \"The ROI on this feature seems promising based on current metrics.\",\n//         \"We need to consider the cost implications of this infrastructure change.\",\n//         \"From a financial perspective, we should prioritize features with higher revenue potential.\"\n//       ],\n//       'Professor': [\n//         \"This approach aligns with recent research in the field.\",\n//         \"Consider the theoretical implications of this decision framework.\",\n//         \"We should examine some case studies that have implemented similar solutions.\",\n//         \"The methodology needs more rigorous validation before proceeding.\"\n//       ]\n//     };\n\n//     const options = feedbackOptions[role] || [\"I have some insights to share about this discussion.\"];\n//     return options[Math.floor(Math.random() * options.length)];\n//   };\n\n//   const toggleVideo = () => {\n//     if (streamRef.current) {\n//       streamRef.current.getVideoTracks().forEach(track => {\n//         track.enabled = !videoEnabled;\n//       });\n//       setVideoEnabled(!videoEnabled);\n//     }\n//   };\n\n//   const toggleAudio = () => {\n//     if (streamRef.current) {\n//       streamRef.current.getAudioTracks().forEach(track => {\n//         track.enabled = !audioEnabled;\n//       });\n//       setAudioEnabled(!audioEnabled);\n//     }\n//   };\n\n//   const leaveRoom = () => {\n//     navigate('/'); // Navigate to home page\n//   };\n\n//   const sendMessage = (message) => {\n//     if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {\n//       socketRef.current.send(JSON.stringify({\n//         type: 'message',\n//         message: message,\n//         sender: userName,\n//         is_ai: false\n//       }));\n//     }\n//   };\n\n//   return (\n//     <VideoRoomContainer>\n//       <Header>\n//         <RoomTitle>Room {roomId}</RoomTitle>\n//       </Header>\n\n//       <FeedbackSection>\n//         {aiFeedback.map((feedback, index) => (\n//           <FeedbackItem key={index}>\n//            <Avatar>\n//   <img \n//     src={`/img/${feedback.agent.toLowerCase()}.png`} \n//     alt={feedback.agent} \n//     style={{ width: '100%', height: '100%', objectFit: 'cover', borderRadius: '50%' }} \n//   />\n// </Avatar>\n\n//             <FeedbackContent>\n//               <AgentName>{feedback.agent}</AgentName>\n//               <FeedbackText>{feedback.content}</FeedbackText>\n//             </FeedbackContent>\n//           </FeedbackItem>\n//         ))}\n//       </FeedbackSection>\n\n//       <VideoGrid>\n//         {peers.map((peer) => (\n//           <VideoContainer key={peer.id}>\n//             <ParticipantVideo\n//               autoPlay\n//               playsInline\n//               ref={(video) => {\n//                 if (video) video.srcObject = peer.stream;\n//               }}\n//             />\n//             <ParticipantName>{peer.id}</ParticipantName>\n//           </VideoContainer>\n//         ))}\n\n//         {participants.filter(p => p.is_ai).map((aiParticipant) => (\n//           <VideoContainer key={aiParticipant.id}>\n//             <Avatar style={{ width: '100%', height: '100%', borderRadius: 0 }}>\n//               <span style={{ fontSize: '36px' }}>{aiParticipant.name[0]}</span>\n//             </Avatar>\n//             <ParticipantName>{aiParticipant.name}</ParticipantName>\n//           </VideoContainer>\n//         ))}\n\n//         {/* Self video in bottom right corner */}\n//         <SelfVideoContainer visible={videoEnabled}>\n//           <ParticipantVideo \n//             ref={userVideo} \n//             autoPlay \n//             playsInline \n//             muted\n//           />\n//           <ParticipantName>{userName}</ParticipantName>\n//         </SelfVideoContainer>\n//       </VideoGrid>\n\n//       <ControlBar>\n//         <ChatButton onClick={() => setShowChat(!showChat)}>\n//           <span role=\"img\" aria-label=\"chat\">💬</span>\n//         </ChatButton>\n\n//         <ControlButton onClick={toggleAudio}>\n//           <span role=\"img\" aria-label=\"microphone\">\n//             {audioEnabled ? '🎙️' : '🔇'}\n//           </span>\n//         </ControlButton>\n\n//         <ControlButton onClick={toggleVideo}>\n//           <span role=\"img\" aria-label=\"camera\">\n//             {videoEnabled ? '📹' : '🚫'}\n//           </span>\n//         </ControlButton>\n\n//         <ControlButton danger onClick={leaveRoom}>\n//           <span role=\"img\" aria-label=\"hang up\">❌</span>\n//         </ControlButton>\n//       </ControlBar>\n\n//       {showChat && (\n//         <Chat \n//           messages={messages} \n//           onSendMessage={sendMessage} \n//           onClose={() => setShowChat(false)}\n//           roomId={roomId}\n//         />\n//       )}\n//     </VideoRoomContainer>\n//   );\n// };\n\n// export default VideoRoom;","map":{"version":3,"names":[],"sources":["C:/Users/user/OneDrive/桌面/HCI+D/video_app/frontend/src/components/VideoRoom.js"],"sourcesContent":["// import React, { useState, useEffect, useRef } from 'react';\r\n// import { useParams, useLocation, useNavigate } from 'react-router-dom';\r\n// import styled from 'styled-components';\r\n// import Peer from 'simple-peer';\r\n// import axios from 'axios';\r\n// import Chat from './Chat';\r\n// import { useSearchParams } from 'react-router-dom';\r\n\r\n// const VideoRoomContainer = styled.div`\r\n//   display: flex;\r\n//   flex-direction: column;\r\n//   height: 100vh;\r\n//   width: 100%;\r\n//   position: relative;\r\n// `;\r\n\r\n// const Header = styled.div`\r\n//   display: flex;\r\n//   justify-content: center; // Center the room title\r\n//   align-items: center;\r\n//   padding: 12px 16px;\r\n//   border-bottom: 1px solid #e0e0e0;\r\n// `;\r\n\r\n// const RoomTitle = styled.h2`\r\n//   margin: 0;\r\n//   font-size: 16px;\r\n//   font-weight: 600;\r\n// `;\r\n\r\n// const FeedbackSection = styled.div`\r\n//   flex: 1;\r\n//   overflow-y: auto;\r\n//   padding: 16px;\r\n//   background-color: #fff;\r\n//   border-bottom: 1px solid #e0e0e0;\r\n// `;\r\n\r\n// const FeedbackItem = styled.div`\r\n//   display: flex;\r\n//   margin-bottom: 16px;\r\n// `;\r\n\r\n// const Avatar = styled.div`\r\n//   width: 40px;\r\n//   height: 40px;\r\n//   border-radius: 20px;\r\n//   background-color: #e0e0e0;\r\n//   margin-right: 12px;\r\n//   overflow: hidden;\r\n//   display: flex;\r\n//   justify-content: center;\r\n//   align-items: center;\r\n// `;\r\n\r\n// const AvatarImage = styled.img`\r\n//   width: 100%;\r\n//   height: 100%;\r\n//   object-fit: cover;\r\n// `;\r\n\r\n// const FeedbackContent = styled.div`\r\n//   flex: 1;\r\n// `;\r\n\r\n// const AgentName = styled.div`\r\n//   font-weight: 600;\r\n//   font-size: 14px;\r\n//   margin-bottom: 4px;\r\n// `;\r\n\r\n// const FeedbackText = styled.div`\r\n//   font-size: 14px;\r\n// `;\r\n\r\n// const VideoGrid = styled.div`\r\n//   display: grid;\r\n//   grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\r\n//   gap: 16px;\r\n//   padding: 16px;\r\n//   background-color: #f5f5f5;\r\n//   flex: 1;\r\n//   position: relative;\r\n// `;\r\n\r\n// const VideoContainer = styled.div`\r\n//   position: relative;\r\n//   aspect-ratio: 4/3;\r\n//   background-color: #000;\r\n//   border-radius: 8px;\r\n//   overflow: hidden;\r\n// `;\r\n\r\n// const ParticipantVideo = styled.video`\r\n//   width: 100%;\r\n//   height: 100%;\r\n//   object-fit: cover;\r\n// `;\r\n\r\n// const ParticipantName = styled.div`\r\n//   position: absolute;\r\n//   bottom: 10px;\r\n//   left: 10px;\r\n//   background-color: rgba(0, 0, 0, 0.6);\r\n//   color: white;\r\n//   padding: 4px 8px;\r\n//   border-radius: 4px;\r\n//   font-size: 12px;\r\n// `;\r\n\r\n// // New styled component for self-video in bottom right\r\n// const SelfVideoContainer = styled.div`\r\n//   position: absolute;\r\n//   bottom: 10px; // Position above control bar\r\n//   right: 10px;\r\n//   width: 180px; // Smaller size\r\n//   border-radius: 8px;\r\n//   overflow: hidden;\r\n//   aspect-ratio: 4/3;\r\n//   background-color: #000;\r\n//   z-index: 10;\r\n//   box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\r\n//   display: ${props => props.visible ? 'block' : 'none'}; // Hide when video is off\r\n// `;\r\n\r\n// const ControlBar = styled.div`\r\n//   display: flex;\r\n//   justify-content: center;\r\n//   padding: 16px;\r\n//   background-color: #fff;\r\n//   border-top: 1px solid #e0e0e0;\r\n// `;\r\n\r\n// const ControlButton = styled.button`\r\n//   width: 40px;\r\n//   height: 40px;\r\n//   border-radius: 20px;\r\n//   margin: 0 8px;\r\n//   background-color: ${props => props.danger ? '#ff4d4f' : '#f0f0f0'};\r\n//   color: ${props => props.danger ? 'white' : 'black'};\r\n//   border: none;\r\n//   cursor: pointer;\r\n//   display: flex;\r\n//   align-items: center;\r\n//   justify-content: center;\r\n  \r\n//   &:hover {\r\n//     background-color: ${props => props.danger ? '#ff7875' : '#d9d9d9'};\r\n//   }\r\n// `;\r\n\r\n// const ChatButton = styled.button`\r\n//   display: flex;\r\n//   align-items: center;\r\n//   justify-content: center;\r\n//   width: 40px;\r\n//   height: 40px;\r\n//   border-radius: 20px;\r\n//   background-color: #f0f0f0;\r\n//   border: none;\r\n//   cursor: pointer;\r\n//   margin-right: 16px;\r\n  \r\n//   &:hover {\r\n//     background-color: #d9d9d9;\r\n//   }\r\n// `;\r\n\r\n// const VideoRoom = () => {\r\n//   const { roomId } = useParams();\r\n//   const location = useLocation();\r\n//   const navigate = useNavigate();\r\n//   const [aiPartners, setAiPartners] = useState(location.state?.aiPartners || []);\r\n//   const [userName, setUserName] = useState(localStorage.getItem('userName') || 'You');\r\n//   const [peers, setPeers] = useState([]);\r\n//   const [participants, setParticipants] = useState([]);\r\n//   const [messages, setMessages] = useState([]);\r\n//   const [aiFeedback, setAiFeedback] = useState([]);\r\n//   const [showChat, setShowChat] = useState(false);\r\n//   const [videoEnabled, setVideoEnabled] = useState(true);\r\n//   const [audioEnabled, setAudioEnabled] = useState(true);\r\n  \r\n//   const userVideo = useRef();\r\n//   const peersRef = useRef([]);\r\n//   const socketRef = useRef();\r\n//   const streamRef = useRef();\r\n  \r\n  \r\n//   useEffect(() => {\r\n//     // Connect to the WebSocket\r\n    \r\n//     socketRef.current = new WebSocket(`ws://localhost:8002/ws/chat/${roomId}/`);\r\n    \r\n//     // Get user media and set up connections\r\n//     navigator.mediaDevices.getUserMedia({ video: true, audio: true })\r\n//       .then(stream => {\r\n//         streamRef.current = stream;\r\n//         if (userVideo.current) {\r\n//           userVideo.current.srcObject = stream;\r\n//         }\r\n        \r\n//         // Join room\r\n//         joinRoom();\r\n        \r\n//         // Set up WebSocket handlers\r\n//         setupWebSocket();\r\n        \r\n//         // Get participants and messages\r\n//         fetchParticipants();\r\n//         fetchMessages();\r\n        \r\n//         // Generate AI feedback\r\n//         if (aiPartners.length > 0) {\r\n//           generateAIFeedback();\r\n//         }\r\n//       })\r\n//       .catch(error => {\r\n//         console.error(\"Error accessing media devices:\", error);\r\n//         alert(\"Could not access camera or microphone. Please check permissions.\");\r\n//       });\r\n    \r\n//     return () => {\r\n//       // Clean up\r\n//       if (streamRef.current) {\r\n//         streamRef.current.getTracks().forEach(track => track.stop());\r\n//       }\r\n//       if (socketRef.current) {\r\n//         socketRef.current.close();\r\n//       }\r\n//       peersRef.current.forEach(peer => {\r\n//         if (peer.peer) {\r\n//           peer.peer.destroy();\r\n//         }\r\n//       });\r\n//     };\r\n//   }, [roomId]);\r\n  \r\n//   const joinRoom = async () => {\r\n//     try {\r\n//       // Register participant in the room\r\n//       await axios.post(`/api/rooms/${roomId}/join/`, {\r\n//         name: userName,\r\n        \r\n//         is_ai: false\r\n//       });\r\n      \r\n//       // Register AI partners in the room\r\n//       for (const agent of aiPartners) {\r\n//         await axios.post(`/api/rooms/${roomId}/join/`, {\r\n//           name: agent.name,\r\n//           is_ai: true,\r\n//           ai_agent: agent.id\r\n//         });\r\n//       }\r\n//     } catch (error) {\r\n//       console.error(\"Error joining room:\", error);\r\n//     }\r\n//   };\r\n  \r\n//   const setupWebSocket = () => {\r\n//     socketRef.current.onopen = () => {\r\n//       console.log(\"WebSocket connection established\");\r\n      \r\n//       // Signal to other participants that we've joined\r\n//       socketRef.current.send(JSON.stringify({\r\n//         type: 'signal',\r\n//         signal: { type: 'new-participant' },\r\n//         caller_id: userName\r\n//       }));\r\n//     };\r\n    \r\n//     socketRef.current.onmessage = (event) => {\r\n//       const data = JSON.parse(event.data);\r\n      \r\n//       if (data.type === 'message') {\r\n//         setMessages(prevMessages => [...prevMessages, {\r\n//           sender: data.sender,\r\n//           content: data.message,\r\n//           is_ai: data.is_ai\r\n//         }]);\r\n        \r\n//         // If AI message contains feedback, add it to feedback section\r\n//         if (data.is_ai && data.message_type === 'feedback') {\r\n//           setAiFeedback(prev => [...prev, {\r\n//             agent: data.sender,\r\n//             content: data.message\r\n//           }]);\r\n//         }\r\n//       } else if (data.type === 'signal') {\r\n//         handleSignal(data);\r\n//       }\r\n//     };\r\n    \r\n//     socketRef.current.onerror = (error) => {\r\n//       console.error(\"WebSocket error:\", error);\r\n//     };\r\n    \r\n//     socketRef.current.onclose = () => {\r\n//       console.log(\"WebSocket connection closed\");\r\n//     };\r\n//   };\r\n  \r\n//   const handleSignal = (data) => {\r\n//     const { signal, caller_id, receiver_id } = data;\r\n    \r\n//     // If signal is for a new participant\r\n//     if (signal.type === 'new-participant' && caller_id !== userName) {\r\n//       const peer = createPeer(caller_id);\r\n      \r\n//       peersRef.current.push({\r\n//         peerId: caller_id,\r\n//         peer: peer\r\n//       });\r\n      \r\n//       socketRef.current.send(JSON.stringify({\r\n//         type: 'signal',\r\n//         signal: { type: 'participant-ready' },\r\n//         caller_id: userName,\r\n//         receiver_id: caller_id\r\n//       }));\r\n//     }\r\n    \r\n//     // If signal is from a participant who is ready to connect\r\n//     else if (signal.type === 'participant-ready' && receiver_id === userName) {\r\n//       const peer = addPeer(caller_id, signal);\r\n      \r\n//       peersRef.current.push({\r\n//         peerId: caller_id,\r\n//         peer: peer\r\n//       });\r\n//     }\r\n    \r\n//     // Handle WebRTC signaling\r\n//     else if (signal.sdp || signal.candidate) {\r\n//       const item = peersRef.current.find(p => p.peerId === caller_id);\r\n//       if (item) {\r\n//         item.peer.signal(signal);\r\n//       }\r\n//     }\r\n//   };\r\n  \r\n//   const createPeer = (participantId) => {\r\n//     const peer = new Peer({\r\n//       initiator: true,\r\n//       trickle: false,\r\n//       stream: streamRef.current\r\n//     });\r\n    \r\n//     peer.on('signal', signal => {\r\n//       socketRef.current.send(JSON.stringify({\r\n//         type: 'signal',\r\n//         signal: signal,\r\n//         caller_id: userName,\r\n//         receiver_id: participantId\r\n//       }));\r\n//     });\r\n    \r\n//     peer.on('stream', stream => {\r\n//       setPeers(users => [...users, {\r\n//         id: participantId,\r\n//         stream: stream\r\n//       }]);\r\n//     });\r\n    \r\n//     return peer;\r\n//   };\r\n  \r\n//   const addPeer = (participantId, incomingSignal) => {\r\n//     const peer = new Peer({\r\n//       initiator: false,\r\n//       trickle: false,\r\n//       stream: streamRef.current\r\n//     });\r\n    \r\n//     peer.on('signal', signal => {\r\n//       socketRef.current.send(JSON.stringify({\r\n//         type: 'signal',\r\n//         signal: signal,\r\n//         caller_id: userName,\r\n//         receiver_id: participantId\r\n//       }));\r\n//     });\r\n    \r\n//     peer.on('stream', stream => {\r\n//       setPeers(users => [...users, {\r\n//         id: participantId,\r\n//         stream: stream\r\n//       }]);\r\n//     });\r\n    \r\n//     peer.signal(incomingSignal);\r\n    \r\n//     return peer;\r\n//   };\r\n  \r\n//   const fetchParticipants = async () => {\r\n//     try {\r\n//       const response = await axios.get(`/api/rooms/${roomId}/participants/`);\r\n//       setParticipants(response.data);\r\n//     } catch (error) {\r\n//       console.error(\"Error fetching participants:\", error);\r\n//     }\r\n//   };\r\n  \r\n//   const fetchMessages = async () => {\r\n//     try {\r\n//       const response = await axios.get(`/api/rooms/${roomId}/messages/`);\r\n//       setMessages(response.data);\r\n//     } catch (error) {\r\n//       console.error(\"Error fetching messages:\", error);\r\n//     }\r\n//   };\r\n  \r\n//   const generateAIFeedback = () => {\r\n//     // Simulated AI feedback for demonstration\r\n//     // In a real application, this would come from an AI service\r\n//     const initialFeedback = aiPartners.map(agent => ({\r\n//       agent: agent.name,\r\n//       content: `Hello, I'm ${agent.name}, your ${agent.role} AI assistant. I'm here to help with the meeting.`\r\n//     }));\r\n    \r\n//     setAiFeedback(initialFeedback);\r\n    \r\n//     // Simulate AI sending periodic feedback\r\n//     const feedbackInterval = setInterval(() => {\r\n//       const randomAgent = aiPartners[Math.floor(Math.random() * aiPartners.length)];\r\n//       if (randomAgent) {\r\n//         const feedback = {\r\n//           agent: randomAgent.name,\r\n//           content: generateRandomFeedback(randomAgent.role)\r\n//         };\r\n        \r\n//         setAiFeedback(prev => [...prev, feedback]);\r\n        \r\n//         // Also send to chat\r\n//         if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {\r\n//           socketRef.current.send(JSON.stringify({\r\n//             type: 'message',\r\n//             message: feedback.content,\r\n//             sender: feedback.agent,\r\n//             is_ai: true,\r\n//             message_type: 'feedback'\r\n//           }));\r\n//         }\r\n//       }\r\n//     }, 15000); // Every 15 seconds\r\n    \r\n//     return () => clearInterval(feedbackInterval);\r\n//   };\r\n  \r\n//   const generateRandomFeedback = (role) => {\r\n//     const feedbackOptions = {\r\n//       'Designer': [\r\n//         \"I notice the UI elements could be more consistent. Consider a unified color scheme.\",\r\n//         \"The user flow seems to have some friction points. We should simplify the navigation.\",\r\n//         \"Visual hierarchy could be improved to guide users more effectively.\",\r\n//         \"Have you considered accessibility in this design? Some elements may need better contrast.\"\r\n//       ],\r\n//       'Engineer': [\r\n//         \"The current architecture might have scaling issues with high user loads.\",\r\n//         \"We should consider optimizing the database queries for better performance.\",\r\n//         \"This would be a good opportunity to implement caching to reduce server load.\",\r\n//         \"The current solution works, but we might want to refactor for better maintainability.\"\r\n//       ],\r\n//       'Finance': [\r\n//         \"Based on our projections, we should allocate more resources to marketing.\",\r\n//         \"The ROI on this feature seems promising based on current metrics.\",\r\n//         \"We need to consider the cost implications of this infrastructure change.\",\r\n//         \"From a financial perspective, we should prioritize features with higher revenue potential.\"\r\n//       ],\r\n//       'Professor': [\r\n//         \"This approach aligns with recent research in the field.\",\r\n//         \"Consider the theoretical implications of this decision framework.\",\r\n//         \"We should examine some case studies that have implemented similar solutions.\",\r\n//         \"The methodology needs more rigorous validation before proceeding.\"\r\n//       ]\r\n//     };\r\n    \r\n//     const options = feedbackOptions[role] || [\"I have some insights to share about this discussion.\"];\r\n//     return options[Math.floor(Math.random() * options.length)];\r\n//   };\r\n  \r\n//   const toggleVideo = () => {\r\n//     if (streamRef.current) {\r\n//       streamRef.current.getVideoTracks().forEach(track => {\r\n//         track.enabled = !videoEnabled;\r\n//       });\r\n//       setVideoEnabled(!videoEnabled);\r\n//     }\r\n//   };\r\n  \r\n//   const toggleAudio = () => {\r\n//     if (streamRef.current) {\r\n//       streamRef.current.getAudioTracks().forEach(track => {\r\n//         track.enabled = !audioEnabled;\r\n//       });\r\n//       setAudioEnabled(!audioEnabled);\r\n//     }\r\n//   };\r\n  \r\n//   const leaveRoom = () => {\r\n//     navigate('/'); // Navigate to home page\r\n//   };\r\n  \r\n//   const sendMessage = (message) => {\r\n//     if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {\r\n//       socketRef.current.send(JSON.stringify({\r\n//         type: 'message',\r\n//         message: message,\r\n//         sender: userName,\r\n//         is_ai: false\r\n//       }));\r\n//     }\r\n//   };\r\n  \r\n//   return (\r\n//     <VideoRoomContainer>\r\n//       <Header>\r\n//         <RoomTitle>Room {roomId}</RoomTitle>\r\n//       </Header>\r\n      \r\n//       <FeedbackSection>\r\n//         {aiFeedback.map((feedback, index) => (\r\n//           <FeedbackItem key={index}>\r\n//            <Avatar>\r\n//   <img \r\n//     src={`/img/${feedback.agent.toLowerCase()}.png`} \r\n//     alt={feedback.agent} \r\n//     style={{ width: '100%', height: '100%', objectFit: 'cover', borderRadius: '50%' }} \r\n//   />\r\n// </Avatar>\r\n\r\n//             <FeedbackContent>\r\n//               <AgentName>{feedback.agent}</AgentName>\r\n//               <FeedbackText>{feedback.content}</FeedbackText>\r\n//             </FeedbackContent>\r\n//           </FeedbackItem>\r\n//         ))}\r\n//       </FeedbackSection>\r\n      \r\n//       <VideoGrid>\r\n//         {peers.map((peer) => (\r\n//           <VideoContainer key={peer.id}>\r\n//             <ParticipantVideo\r\n//               autoPlay\r\n//               playsInline\r\n//               ref={(video) => {\r\n//                 if (video) video.srcObject = peer.stream;\r\n//               }}\r\n//             />\r\n//             <ParticipantName>{peer.id}</ParticipantName>\r\n//           </VideoContainer>\r\n//         ))}\r\n        \r\n//         {participants.filter(p => p.is_ai).map((aiParticipant) => (\r\n//           <VideoContainer key={aiParticipant.id}>\r\n//             <Avatar style={{ width: '100%', height: '100%', borderRadius: 0 }}>\r\n//               <span style={{ fontSize: '36px' }}>{aiParticipant.name[0]}</span>\r\n//             </Avatar>\r\n//             <ParticipantName>{aiParticipant.name}</ParticipantName>\r\n//           </VideoContainer>\r\n//         ))}\r\n        \r\n//         {/* Self video in bottom right corner */}\r\n//         <SelfVideoContainer visible={videoEnabled}>\r\n//           <ParticipantVideo \r\n//             ref={userVideo} \r\n//             autoPlay \r\n//             playsInline \r\n//             muted\r\n//           />\r\n//           <ParticipantName>{userName}</ParticipantName>\r\n//         </SelfVideoContainer>\r\n//       </VideoGrid>\r\n      \r\n//       <ControlBar>\r\n//         <ChatButton onClick={() => setShowChat(!showChat)}>\r\n//           <span role=\"img\" aria-label=\"chat\">💬</span>\r\n//         </ChatButton>\r\n        \r\n//         <ControlButton onClick={toggleAudio}>\r\n//           <span role=\"img\" aria-label=\"microphone\">\r\n//             {audioEnabled ? '🎙️' : '🔇'}\r\n//           </span>\r\n//         </ControlButton>\r\n        \r\n//         <ControlButton onClick={toggleVideo}>\r\n//           <span role=\"img\" aria-label=\"camera\">\r\n//             {videoEnabled ? '📹' : '🚫'}\r\n//           </span>\r\n//         </ControlButton>\r\n        \r\n//         <ControlButton danger onClick={leaveRoom}>\r\n//           <span role=\"img\" aria-label=\"hang up\">❌</span>\r\n//         </ControlButton>\r\n//       </ControlBar>\r\n      \r\n//       {showChat && (\r\n//         <Chat \r\n//           messages={messages} \r\n//           onSendMessage={sendMessage} \r\n//           onClose={() => setShowChat(false)}\r\n//           roomId={roomId}\r\n//         />\r\n//       )}\r\n//     </VideoRoomContainer>\r\n//   );\r\n// };\r\n\r\n// export default VideoRoom;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}